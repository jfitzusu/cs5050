import math
import numpy as np


SCORE_MAP = {"A": {"A": 1, "T": -5, "C": -5, "G": -1},
             "T": {"A": -5, "T": 1, "C": -1, "G": -5},
             "C": {"A": -5, "T": -1, "C": 1, "G": -5},
             "G": {"A": -1, "T": -5, "C": -5, "G": 1}
             }

OPEN_GAP = -5

CONTINUE_GAP = -1


'''
Helper Function for Max Score, Doesn't Require the Sequence Indexes
seq1: First Sequence to Compare
seq2: Second Sequence to Compare
returns: Maximum Alignment Score of the Two Sequences
'''
def maxScoreHelper(seq1, seq2):
    return maxScore(seq1, seq2, len(seq1), len(seq2))


'''
Calculates the Alignment Score of 2 Nucleotide Sequences
seq1: First Sequence to Compare
seq2: Second Sequence to Compare
i1: Maximum Index of the First Sequence to Consider
i2: Maximum Index of the Seconds Sequence to Consider
returns: Maximum Alignment Score of the Two Sequences
'''
def maxScore(seq1, seq2, i1, i2):
    # Base Case, Sequences Empty
    if i1 <= 0 and i2 <= 0:
        return 0

    # Base Cases, One Sequence Has Run Out
    if i1 == 0:
        return OPEN_GAP + CONTINUE_GAP * (i2 - 1)

    if i2 == 0:
        return OPEN_GAP + CONTINUE_GAP * (i1 - 1)

    return max(max(OPEN_GAP + maxScoreAGap(seq1, seq2, i1 - 1, i2),
                   OPEN_GAP + maxScoreBGap(seq1, seq2, i1, i2 - 1)),
               SCORE_MAP[seq1[i1]][seq2[i2]] + maxScore(seq1, seq2, i1 - 1, i2 - 1))


'''
Helper Function for maxScore, Considers the Sequence after Having Opened a Gap in seq1
seq1: First Sequence to Compare
seq2: Second Sequence to Compare
i1: Maximum Index of the First Sequence to Consider
i2: Maximum Index of the Seconds Sequence to Consider
returns: Maximum Alignment Score of the Two Sequences After a Gap Has Been Opened
'''
def maxScoreAGap(seq1, seq2, i1, i2):
    if i1 <= 0:
        return OPEN_GAP + CONTINUE_GAP * (i2 - 1)

    if i2 <= 0:
        return CONTINUE_GAP * i1

    return max(CONTINUE_GAP + maxScoreAGap(seq1, seq2, i1 - 1, i2),
               SCORE_MAP[seq1[i1]][seq2[i2]] + maxScore(seq1, seq2, i1 - 1, i2 - 1))


'''
Helper Function for maxScore, Considers the Sequence after Having Opened a Gap in seq2
seq1: First Sequence to Compare
seq2: Second Sequence to Compare
i1: Maximum Index of the First Sequence to Consider
i2: Maximum Index of the Seconds Sequence to Consider
returns: Maximum Alignment Score of the Two Sequences After a Gap Has Been Opened
'''
def maxScoreBGap(seq1, seq2, i1, i2):
    if i2 <= 0:
        return OPEN_GAP + CONTINUE_GAP * (i1 - 1)

    if i1 <= 0:
        return CONTINUE_GAP * i2

    return max(CONTINUE_GAP + maxScoreBGap(seq1, seq2, i1, i2 - 1),
               SCORE_MAP[seq1[i1]][seq2[i2]] + maxScore(seq1, seq2, i1 - 1, i2 - 1))


'''
Calculates the Alignment Score of 2 Nucleotide Sequences
seq1: First Sequence to Compare
seq2: Second Sequence to Compare
returns: The Solution Array Containing All Possible Alignment Scores, resultsArray[len(seq1) - 1][len(seq2) - 1][0] Represents Maximum Value
'''
def maxScoreDP(seq1, seq2):
    resultsArray = np.array(np.zeros((len(seq1), len(seq2), 3)), dtype=int)

    # Base Cases, One Sequence has Run Out, and a Gap is Opened
    for i in range(1, len(resultsArray)):
        resultsArray[i][0][0] = OPEN_GAP + (i - 1) * CONTINUE_GAP
        resultsArray[i][0][1] = i * CONTINUE_GAP
        resultsArray[i][0][2] = OPEN_GAP + (i - 1) * CONTINUE_GAP

    for j in range(1, len(resultsArray[0])):
        resultsArray[0][j][0] = -5 + (j - 1) * -1
        resultsArray[0][j][1] = -5 + (j - 1) * -1
        resultsArray[0][j][2] = j * -1

    for i in range(1, len(resultsArray)):
        for j in range(1, len(resultsArray[i])):
            resultsArray[i][j][2] = max(resultsArray[i][j - 1][2] + CONTINUE_GAP,
                                        resultsArray[i - 1][j - 1][0] + SCORE_MAP[seq1[i]][seq2[j]])
            resultsArray[i][j][1] = max(resultsArray[i - 1][j][1] + CONTINUE_GAP,
                                        resultsArray[i - 1][j - 1][0] + SCORE_MAP[seq1[i]][seq2[j]])
            resultsArray[i][j][0] = max(OPEN_GAP + resultsArray[i - 1][j][1],
                                        OPEN_GAP + resultsArray[i][j - 1][2],
                                        SCORE_MAP[seq1[i]][seq2[j]] + resultsArray[i - 1][j - 1][0])

    return resultsArray


'''
Generates the Alignment Chart for 2 Nucleotide Sequences
solutions: The Alignment Values Generated by maxScoreDP
seq1: The First Sequence
seq2: The Seconds Sequence
returns: An Array Containing Each String Formatted for the Print Function   
'''
def traceBack(solutions, seq1, seq2):
    i = len(solutions) - 1
    j = len(solutions[i]) - 1
    k = 0

    # Creates a Results Array of the Maximum Possible Size
    backTrack = np.array(np.zeros(((i + j - 1), 3)), dtype=str) # NOTE: the 0th Index Keeps Track of Whether a Gap Was Opened/Closed at that Location
    index = len(backTrack) - 1

    while i > 0 or j > 0:

        # Case Where no Gaps were Created
        if k == 0:
            if solutions[i][j][k] == OPEN_GAP + solutions[i - 1][j][1]:
                backTrack[index][0] = 1
                backTrack[index][1] = seq1[i]
                backTrack[index][2] = "|"

                i -= 1
                k = 1

            elif solutions[i][j][k] == OPEN_GAP + solutions[i][j - 1][2]:
                backTrack[index][0] = 1
                backTrack[index][1] = "|"
                backTrack[index][2] = seq2[j]

                j -= 1
                k = 2

            elif solutions[i][j][k] == SCORE_MAP[seq1[i]][seq2[j]] + solutions[i - 1][j - 1][0]:
                backTrack[index][0] = 0
                backTrack[index][1] = seq1[i]
                backTrack[index][2] = seq2[j]

                j -= 1
                i -= 1

        # Case Where a Gap was Created in seq1
        elif k == 1:
            if solutions[i][j][k] == CONTINUE_GAP + solutions[i - 1][j][1]:
                backTrack[index][0] = 0
                backTrack[index][1] = seq1[i]
                backTrack[index][2] = "|"

                i -= 1

            elif solutions[i][j][k] == SCORE_MAP[seq1[i]][seq2[j]] + solutions[i - 1][j - 1][0]:
                backTrack[index][0] = -1
                backTrack[index][1] = seq1[i]
                backTrack[index][2] = seq2[j]

                i -= 1
                j -= 1
                k = 0

        # Case Where a Gap was Created in seq2
        elif k == 2:
            if solutions[i][j][k] == CONTINUE_GAP + solutions[i][j - 1][2]:
                backTrack[index][0] = 0
                backTrack[index][1] = "|"
                backTrack[index][2] = seq2[j]

                j -= 1

            elif solutions[i][j][k] == SCORE_MAP[seq1[i]][seq2[j]] + solutions[i - 1][j - 1][0]:
                backTrack[index][0] = -1
                backTrack[index][1] = seq1[i]
                backTrack[index][2] = seq2[j]

                i -= 1
                j -= 1
                k = 0

        index -= 1

    return backTrack


'''
Uses the Specially Formateed Array from traceBack() to Print a Sequence Alignment
backTrace: Sequence Array
maxPrint: Maximum Values to Print in the Sequence
'''
def printTraceBack(backTrace, maxPrint=math.inf):

    print("Start of String Alignment")
    print("-------------------------")

    i = 0
    printed = 0
    while printed < maxPrint and i < len(backTrace):
        if backTrace[i, 1] != "0.0":
            print(f"{backTrace[i, 1]}     {backTrace[i, 2]}")
            printed += 1
        if backTrace[i][0] == "1" or backTrace[i][0] == "-1":
            print("------")
        i += 1
